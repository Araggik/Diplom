routine BC_Node(InOut Con[10])
 initial
   Print "I'm node";   
   array[100] of integer IdWallets,KeyWallets;
   array[100] of real AmountWallets,Powers;
   array[100] of string NameWallets,ArrayMessage,ArrayTran;
   array[100] of string Register,Transactions,ArrayBlock;
   array[100] of real MTree;
   integer count_wallets,count_nodes,count_tran_block;
   integer t,mode,i,j,start_send,net_reward,p,count_p;
   integer nonce,zero_count,time_stamp,size_hash,cur_steps;
   integer count_blocks, current_wallet, to_id,from_id;
   integer cur_count_tran, minrand,maxrand,cur_count_hashes;
   integer minnonce,maxnonce, count_steps, count_accept;
   integer cur_leaf, count_leafs, last_leaf,cur_accept;
   integer create_id_bk,check_id_bk;
   real own_wallet,number,hash,prev_hash,amount,reward;
   real hash_limit,bk_hash;
   boolean flag, flag2, fg_block, fg_tree,fg_nonce;
   boolean fg_zero, my_block, fg_check;
   string s,block,tran,for_hash,sch,check_block,response;
   string recieve_tran;
   array[100] of char num;
   schedule InitialEvent in 0;
 endi
 event;
   ArrayMessage:=Split(message,' ');
   if ArrayMessage[0] = "Key" then
     i:=0;
	 flag:=true;
	 while((i<count_wallets) & flag) do	   
	   if ArrayMessage[1] = IntToStr(KeyWallets[i]) then
	     current_wallet:=i;
	     flag:=false;
		 mode:=2;
		 s:="";
		 s:="Wallet"+" "+NameWallets[i]+" "+RealToStr(AmountWallets[i]);
		 out s through Con[0];
		 s:="";
		 s:="Names"+" "+IntToStr(count_wallets);
		 j:=0;
		 while (j<count_wallets) do
		   s:=s+" "+NameWallets[j];
		   j:=j+1;
		 endw;
		 out s through Con[0];
	   endif;	   
	   i:=i+1;
	 endw;
     if(flag) then
	  s:="";
	  s:="Wallet"+" "+"0";
	  out s through Con[0];
     endif;	 
   else
     if ArrayMessage[0] = "Tran" then
	   schedule ValidTran in 0;
	 else
	   if ArrayMessage[0] = "Tran_node" then
	     Print "Receive transaction #"+ArrayMessage[1]+" ["+ArrayMessage[2]+", "+ArrayMessage[3]+", "+ArrayMessage[4]+", "+ArrayMessage[5]+" ]";
	     recieve_tran:=message;
	     schedule ValidTranNode in 0;
	   else 
	     if ArrayMessage[0] = "Block" then
		    check_block:=message;
		    schedule CheckBlock in 0;
		 else
		   if ArrayMessage[0] = "Response" then
		       if StrToInt(ArrayMessage[1]) = nonce then
			     response:=message;
			     schedule AddAccept in 0;
			   endif;   		        
		   endif;
		 endif;
	   endif;
     endif;	 
   endif;  
 ende 
 event InitialEvent;
   Print "InitialEvent";
   start_send:=2;
   mode:=1;
   own_wallet:=0;
   fg_block:=false;
   cur_count_tran:=0;
   count_blocks:=0;
   count_wallets:=4;
   count_nodes:=3;
   count_accept:=(integer)count_nodes/2;
   count_tran_block:=4;
   net_reward:=1;
   time_stamp:=0;
   for_hash:="1!";
   p:=31;
   count_p:=30;
   zero_count:=1;
   minrand:=100;
   maxrand:=999;
   minnonce:=10000;
   maxnonce:=99999;
   hash_limit:=10000000;
   size_hash:=5;
   hash:=0;
   IdWallets[0]:=0;
   KeyWallets[0]:=1239876;
   AmountWallets[0]:=10000;
   NameWallets[0]:="Tom";
   IdWallets[1]:=1;
   KeyWallets[1]:=9876123;
   AmountWallets[1]:=50000;
   NameWallets[1]:="Nick";
   IdWallets[2]:=2;
   KeyWallets[2]:=1234987;
   AmountWallets[2]:=15000;
   NameWallets[2]:="Den";
   IdWallets[3]:=3;
   KeyWallets[3]:=3459876;
   AmountWallets[3]:=10000;
   NameWallets[3]:="Eve";
   cur_accept:=0;
   fg_check:=true;
   schedule FillPowers in 0;
   schedule SendTransaction in start_send;
 ende
 event FillPowers;
   i:=0;
   number:=1;
   while (i<count_p) do
    Powers[i]:=number;
    number:=number*p;
    i:=i+1;	
   endw;   
   schedule FirstBlock in 0;
   schedule FindHash in 0;
 ende
 event FindHash;
   num:=StrToCharArray(for_hash);
   hash:=0;
   i:=0;
   while((num[i] !='!') &(i<size_hash)) do
     s:=CharToStr(num[i]);	 
     hash:=hash+(StrToInt(s)*Powers[i]);
	 i:=i+1;
   endw;
   if (fg_block) then
     cur_count_hashes:=cur_count_hashes+1;
	 if(fg_tree) then
	    cur_leaf:=cur_leaf+2;
		count_leafs:=count_leafs-1;
	 else
        if(fg_nonce) then
		  count_steps:=count_steps+1;
        endif;		
	 endif;
	 schedule Mine in 0;
   endif; 
   (*
   while(hash>hash_limit) do
     hash:=hash/10;
   endw;
   hash:=(integer)(hash);*)
   if (!fg_check) then
     schedule CheckBlock in 0;
   endif;
 ende
 event FirstBlock;
   fg_block:=true;
   prev_hash:=hash;
   block:="0";
   block:=block+" "+IntToStr(time_stamp);
   block:=block+" "+RealToStr(hash);
   block:=block+" "+"0";
   block:=block+" "+IntToStr(nonce);
   block:=block+" "+"0";
   schedule AddBlock in 0;
   schedule AddTime in 1;
 ende
 event AddBlock;
   Print "Add block";
   if (count_blocks>0) then
     ArrayBlock:=Split(block,' ');
	 i:=0;
	 while (i<count_tran_block) do
	   j:=StrToInt(ArrayBlock[i*5+8]);
	   AmountWallets[j]:=AmountWallets[j]+StrToReal(ArrayBlock[i*5+9]);
	   j:=StrToInt(ArrayBlock[i*5+7]);
	   AmountWallets[j]:=AmountWallets[j]-StrToReal(ArrayBlock[i*5+9]);
	   if (my_block) then
	     own_wallet:=own_wallet+StrToReal(ArrayBlock[i*5+10]);
	   endif;	   
	   i:=i+1;
	 endw;
	 if(my_block) then
	   own_wallet:=own_wallet+net_reward;
	 endif;  
	 prev_hash:=StrToReal(ArrayBlock[2]);
   endif;
   cur_accept:=0;
   cur_count_tran:=0;   
   Register[count_blocks]:=block;
   count_blocks:=count_blocks+1;
   my_block:=false;
 ende
 event ValidTran;
   Print "Validate transaction from client";
   i:=0;
   flag:=true;
   flag2:=true;
   while ((i<count_wallets) & (flag | flag2)) do 
     if (flag & (ArrayMessage[1] = NameWallets[i]) &(i = current_wallet)) then
	    flag:=false;
	 endif;
	 if (flag2 & (ArrayMessage[2] = NameWallets[i])) then
	    flag2:=false;
		to_id:=i;
	 endif;
     i:=i+1;
   endw;
   if(!flag & !flag2) then 
    (*amount*)
    amount:=StrToReal(ArrayMessage[3]);
    reward:=StrToReal(ArrayMessage[4]);
    if( AmountWallets[current_wallet] >= (amount+reward)) then
      tran:=IntToStr(count_blocks)+IntToStr(RandomIn(minrand,maxrand));
	  Print "Send transaction #" + tran;
      tran:=tran+" "+IntToStr(current_wallet);
	  tran:=tran+" "+IntToStr(to_id);
	  tran:=tran+" "+ArrayMessage[3];
	  tran:=tran+" "+ArrayMessage[4];
	  Transactions[cur_count_tran]:=tran;
	  cur_count_tran:=cur_count_tran+1;
	  tran:="Tran_node"+" "+tran;
	  i:=1;	  
	  while (i<count_nodes) do
	    out tran through Con[i];
	    i:=i+1;
	  endw;
	  if cur_count_tran = count_tran_block then
	    cur_count_hashes:=0;
		fg_tree:=false;
		fg_nonce:=false;
		fg_block:=true;
		Print "Start mine";
	    schedule Mine in 1;
	  endif;
    endif;
   endif;
 ende
 event SendTransaction;
   if mode = 1 then     
   endif;
 ende
 event AddTime;
  time_stamp:=time_stamp+1;
  schedule AddTime in 1;
 ende
 event ValidTranNode;
   ArrayMessage:=Split(recieve_tran,' ');
   Print "Validate transaction #"+ArrayMessage[1];
   i:=0;
   flag:=true;
   flag2:=true;
   from_id:=StrToInt(ArrayMessage[2]);
   to_id:=StrToInt(ArrayMessage[3]);
   while ((i<count_wallets) & (flag | flag2)) do 
     if (flag & (IdWallets[i]=from_id)) then
	    flag:=false;
	 endif;
	 if (flag2 & (IdWallets[i]=to_id)) then
	    flag2:=false;
	 endif;
     i:=i+1;
   endw;
   if(!flag & !flag2) then
    amount:=StrToReal(ArrayMessage[4]);
    reward:=StrToReal(ArrayMessage[5]);
    if( AmountWallets[current_wallet] >= (amount+reward)) then
      tran:=ArrayMessage[1];
      tran:=tran+" "+ArrayMessage[2];
	  tran:=tran+" "+ArrayMessage[3];
	  tran:=tran+" "+ArrayMessage[4];
	  tran:=tran+" "+ArrayMessage[5];
	  Transactions[cur_count_tran]:=tran;
	  cur_count_tran:=cur_count_tran+1;
	  if cur_count_tran = count_tran_block then
	    cur_count_hashes:=0;
		fg_tree:=false;
		fg_nonce:=false;
		fg_block:=true;
		Print "Start mine";
	    schedule Mine in 1;
	  endif;
    endif; 
   endif;   
 ende
 event Mine;
   if(cur_count_hashes <count_tran_block) then    
     if (cur_count_hashes>0) then
	   MTree[cur_count_hashes-1]:=hash;
	 endif;
     ArrayTran:=Split(Transactions[cur_count_hashes],' ');
	 s:="";
	 s:=s+ArrayTran[0]+ArrayTran[1]+ArrayTran[2]+ArrayTran[3]+ArrayTran[4];
	 for_hash:=s+"!";
     schedule FindHash in 0;
   else
    if (cur_count_hashes = count_tran_block) then
      MTree[cur_count_hashes-1]:=hash;
	  fg_tree:=true;
	  cur_leaf:=0;
	  last_leaf:=cur_count_hashes-1;
	  count_leafs:=count_tran_block;
	  for_hash:=RealToStr(MTree[cur_leaf]+MTree[cur_leaf+1])+"!";
	  schedule FindHash in 0;
	else
	  if(last_leaf!=1) then  
	    MTree[(integer)((cur_leaf-2)/2)]:=hash;
	    if cur_leaf > last_leaf then
	      cur_leaf:=0;
		  last_leaf:=count_leafs-1;		
	    else
		  if cur_leaf = last_leaf then
		    cur_leaf:=0;
		    MTree[cur_leaf]:=MTree[last_leaf];
		    last_leaf:=count_leafs-1;
		  endif;
	    endif;
	    for_hash:=RealToStr(MTree[cur_leaf])+RealToStr(MTree[cur_leaf+1])+"!";
	    schedule FindHash in 0;
	  else
		if(fg_tree) then
	      MTree[(integer)((cur_leaf-2)/2)]:=hash;
		  nonce:=RandomIn(minnonce,maxnonce);
		  count_steps:=0;
		  for_hash:=IntToStr(nonce)+RealToStr(hash)+"!";	  
		  fg_tree:=false;
	      fg_nonce:=true; 
		  schedule FindHash in 0;
		else
		  s:=RealToStr(hash);
		  num:=StrToCharArray(s);
		  fg_zero:=true;
		  i:=0;
		  while ((i<zero_count)&fg_zero) do
		   if(num[i] !='1') then
		     fg_zero:=false;
		   endif;
		   i:=i+1;
		  endw;
		  if(fg_zero) then
		   Print "Find nonce " + IntToStr(nonce);
		   fg_block:=false;
		   for_hash:=RealToStr(MTree[0])+RealToStr(prev_hash)+"!";
		   schedule CreateBlock in 0;
		   schedule FindHash in 0;
		  else
		   nonce:=nonce+1;
		   for_hash:=IntToStr(nonce)+RealToStr(MTree[0])+"!";	
		   schedule FindHash in 0;
		  endif;
		endif;  	          
	  endif;  
	endif;
   endif;
 ende
 event CreateBlock;  
   create_id_bk:=count_blocks;
   block:=IntToStr(count_blocks);
   Print "Create block #"+block;
   block:=block+" "+IntToStr(time_stamp);
   block:=block+" "+RealToStr(hash);
   block:=block+" "+RealToStr(prev_hash);
   block:=block+" "+IntToStr(nonce);
   block:=block+" "+RealToStr(MTree[0]);
   i:=0;
   while (i<count_tran_block) do
      block:=block+" "+Transactions[i];
	  i:=i+1;
   endw;  
   bk_hash:=hash;
   schedule SendBlock in 1;
 ende
 event SendBlock;
   Print "Send block";
   i:=1;
   s:="Block"+" "+IntToStr(count_steps)+" "+block;
   while (i<=count_nodes) do
      out s through Con[i];
      i:=i+1;
   endw;
 ende
 event CheckBlock;   
   ArrayBlock:=Split(check_block,' ');
   if(fg_check) then
     fg_check:=false;	 
     for_hash:=ArrayBlock[6]+ArrayBlock[7]+"!";	 
	 schedule FindHash in 0;
   else
     Print "Check recieve block";
     s:=RealToStr(hash);
     num:=StrToCharArray(s);
	 i:=0;
	 fg_zero:=true;
	 while ((i<zero_count)&fg_zero) do
	   if(num[i] !='1') then
		  fg_zero:=false;
	   endif;
	   i:=i+1;
	 endw;
	 cur_steps:=StrToInt(ArrayBlock[1]);
	 check_id_bk:=StrToInt(ArrayBlock[2]);
	 sch:="f";
	 if(fg_zero & ((check_id_bk = create_id_bk) & (cur_steps<count_steps))) then
        sch:="t";
		block:=ArrayBlock[2];
		i:=3;
		while (i<=7) do
		  block:=block+" "+ArrayBlock[i];
		  i:=i+1;
		endw;
		i:=0;
		while (i<count_tran_block) do
		  block:=block+" "+ArrayBlock[i*5+8];
		  block:=block+" "+ArrayBlock[i*5+9];
		  block:=block+" "+ArrayBlock[i*5+10];
		  block:=block+" "+ArrayBlock[i*5+11];
		  block:=block+" "+ArrayBlock[i*5+12];
		  i:=i+1;
		endw;
		Print block;
		schedule AddBlock in 0;
	 endif;
	 i:=1;
	 while (i<=count_nodes) do
	     s:="Response"+" "+ArrayBlock[6]+" "+sch;
		 out s through Con[i];
	     i:=i+1;
	 endw;
	 fg_check:=true;
   endif;  
 ende
 event AddAccept;
   ArrayMessage:=Split(response,' ');
   s:=ArrayMessage[2];
   if s = "t" then
     cur_accept:=cur_accept+1;
   endif;
   if cur_accept>=count_accept then
     my_block:=true;
     schedule AddBlock in 0;
   endif;	 
 ende
endrout 