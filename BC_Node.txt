routine BC_Node(InOut Con[10])
 initial
   Print "I'm node";   
   real count_transactions, count_res_trans, count_res_blocks;
   count_transactions:=0;
   array[100] of integer IdWallets,KeyWallets;
   array[100] of real AmountWallets,Powers;
   array[100] of string NameWallets,ArrayTran,Register2;
   array[1000] of string ArrayMessage;
   array[100] of string Register,Transactions,ArrayBlock,log;
   array[100] of string pool_trans,pool_blocks, pool_cl_trans;
   array[100] of real MTree;
   integer count_wallets,count_nodes,count_tran_block;
   integer t,mode,i,j,z,v,start_send,net_reward,p,count_p;
   integer nonce,zero_count,time_stamp,size_hash,cur_steps;
   integer count_blocks, current_wallet, to_id,from_id;
   integer cur_count_tran, minrand,maxrand,cur_count_hashes;
   integer minnonce,maxnonce, count_steps, count_accept;
   integer cur_leaf, count_leafs, last_leaf,cur_accept;
   integer create_id_bk,check_id_bk, oind;
   integer count_valid_tran,last_log;
   integer last_pool_tran, last_pool_block, last_pool_cl_tran;
   real own_wallet,number,hash,prev_hash,amount,reward;
   real hash_limit,bk_hash;
   real ohash, oprev_hash, oroot;
   boolean flag, flag2, fg_tree,not_accept;
   boolean fg_zero, my_block,has_register,valid_register;
   string s,block,tran,for_hash,sch,response,other_block;
   array[100] of char num;
   own_wallet:=0; 
   count_blocks:=0;
   count_valid_tran:=0;   
   last_log:=0;
   schedule InitialEvent in 0;
 endi
 event;
   Print message;
   ArrayMessage:=Split(message,' ');
   if ArrayMessage[0] = "Key" then
     i:=0;
	 flag:=true;
	 while((i<count_wallets) & flag) do	   
	   if ArrayMessage[1] = IntToStr(KeyWallets[i]) then
	     current_wallet:=i;
	     flag:=false;
		 mode:=2;
		 s:="";
		 s:="Wallet"+" "+NameWallets[i]+" "+RealToStr(AmountWallets[i]);
		 out s through Con[0];
		 s:="";
		 s:="Names"+" "+IntToStr(count_wallets);
		 j:=0;
		 while (j<count_wallets) do
		   s:=s+" "+NameWallets[j];
		   j:=j+1;
		 endw;
		 out s through Con[0];
	   endif;	   
	   i:=i+1;
	 endw;
     if(flag) then
	  s:="";
	  s:="Wallet"+" "+"0";
	  out s through Con[0];
     endif;	 
   else
     if ArrayMessage[0] = "Tran" then
	   pool_cl_trans[last_pool_cl_tran]:=message;
	   last_pool_cl_tran:=last_pool_cl_tran+1;
	   schedule ValidTran in 0;
	 else
	   if ArrayMessage[0] = "Tran_node" then
	     (*Print "Receive transaction #"+ArrayMessage[1]+" ["+ArrayMessage[2]+", "+ArrayMessage[3]+", "+ArrayMessage[4]+", "+ArrayMessage[5]+" ]";*)
		 pool_trans[last_pool_tran]:=message;
	     last_pool_tran:=last_pool_tran+1;
	     schedule ValidTranNode in 0;
	   else 
	     if ArrayMessage[0] = "Block" then
		    pool_blocks[last_pool_block]:=message;
			last_pool_block:=last_pool_block+1;
		    schedule CheckBlock in 0;
		 else
		   if ArrayMessage[0] = "Response" then
		       if StrToInt(ArrayMessage[1]) = nonce then
                  s:=ArrayMessage[2];
                  if s = "t" then
                    cur_accept:=cur_accept+1;
                  endif;
                  if((cur_accept=count_accept) & not_accept) then
				    not_accept:=false;
                    my_block:=true;
                    schedule AddBlock in 0;
                  endif;	 
			   endif;  
           else
		     if ArrayMessage[0] = "Register" then
			   (*j-count blocks in register*)
			   j:=StrToInt(ArrayMessage[1]);
               if (count_blocks<j) then
			      Print "Check register";
			      valid_register:=true;			      
				  oprev_hash:=StrToReal(ArrayMessage[4+count_wallets]);
				  Register2[0]:=Register[0];
			      v:=0;
				  while ((v<j-1)&valid_register) do
				    Print "Check block "+IntToStr(v);
				    oind:=2+count_wallets+6+(v*(count_tran_block*5+6));
					(*hash*)
					Print oind;
					for_hash:=ArrayMessage[oind+5]+ArrayMessage[oind+3]+"!";
					num:=StrToCharArray(for_hash);					
                    hash:=0;
                    i:=0;
                    while((num[i] !='!') &(i<size_hash)) do
                      s:=CharToStr(num[i]);	 
                      hash:=hash+(StrToInt(s)*Powers[i]);
	                  i:=i+1;
                    endw;  
					Print "Calc hash "+RealToStr(hash);
					Print ArrayMessage[oind+2];
					if (RealToStr(hash) != ArrayMessage[oind+2]) then
					  valid_register:=false;
					endif;
					(*nonce*)
					if (valid_register) then
					  Print "Hash is valid";
					  for_hash:=ArrayMessage[oind+4]+ArrayMessage[oind+5]+"!";
					  num:=StrToCharArray(for_hash);
                      hash:=0;
                      i:=0;
                      while((num[i] !='!') &(i<size_hash)) do
                        s:=CharToStr(num[i]);	 
                        hash:=hash+(StrToInt(s)*Powers[i]);
	                    i:=i+1;
                      endw;  
				  	  s:=RealToStr(hash);
                      num:=StrToCharArray(s);
	                  i:=0;
	                  while ((i<zero_count)&valid_register) do
	                   if(num[i] !='1') then
		                valid_register:=false;
	                   endif;
	                   i:=i+1;
	                  endw;
					  if valid_register then	
                        Print "nonce is valid";					  
				        other_block:=ArrayMessage[oind];
				        other_block:=other_block+" "+ArrayMessage[oind+1];
				        other_block:=other_block+" "+ArrayMessage[oind+2];
				        other_block:=other_block+" "+ArrayMessage[oind+3];
				        other_block:=other_block+" "+ArrayMessage[oind+4];
				        other_block:=other_block+" "+ArrayMessage[oind+5];
				        z:=0;
				        while (z < count_tran_block) do
					      other_block:=other_block+" "+ArrayMessage[z*5+oind+6];
						  other_block:=other_block+" "+ArrayMessage[z*5+oind+7];
						  other_block:=other_block+" "+ArrayMessage[z*5+oind+8];
						  other_block:=other_block+" "+ArrayMessage[z*5+oind+9];
						  other_block:=other_block+" "+ArrayMessage[z*5+oind+10];
					      z:=z+1;
					    endw;
					  endif;
					endif;
					Print "Add block "+other_block;					
				    v:=v+1;
					Register2[v]:=other_block;
				  endw;
				  if (valid_register) then
				    Print "Change register";
				    count_blocks:=j;
					count_res_blocks:=count_blocks;
					count_res_trans:=count_tran_block*(count_blocks-1);
					Register:=Register2;
					i:=0;
					while (i<count_wallets) do
					  AmountWallets[i]:=StrToReal(ArrayMessage[1+i]);
					  i:=i+1;
					endw;
				  endif;
			   endif;
			 else
			   (*log[last_log]:=message;
			   if last_log = 0 then 
			     schedule Loge in 2;
			   endif;
               last_log:=last_log+1;*)	
			 endif;            		 
		   endif;
		 endif;
	   endif;
     endif;	 
   endif;  
 ende 
 event InitialEvent;
   Print "InitialEvent";
   start_send:=2;
   mode:=1;
   own_wallet:=0;
   cur_count_tran:=0;
   count_blocks:=0;
   count_wallets:=4;
   count_nodes:=3;
   count_accept:=(integer)count_nodes/2;
   count_tran_block:=4;
   net_reward:=1;
   time_stamp:=0;
   for_hash:="1!";
   p:=31;
   count_p:=30;
   zero_count:=1;
   minrand:=100;
   maxrand:=999;
   minnonce:=10000;
   maxnonce:=99999;
   hash_limit:=10000000;
   size_hash:=5;
   hash:=0;
   IdWallets[0]:=0;
   KeyWallets[0]:=1239876;
   AmountWallets[0]:=10000;
   NameWallets[0]:="Tom";
   IdWallets[1]:=1;
   KeyWallets[1]:=9876123;
   AmountWallets[1]:=50000;
   NameWallets[1]:="Nick";
   IdWallets[2]:=2;
   KeyWallets[2]:=1234987;
   AmountWallets[2]:=15000;
   NameWallets[2]:="Den";
   IdWallets[3]:=3;
   KeyWallets[3]:=3459876;
   AmountWallets[3]:=10000;
   NameWallets[3]:="Eve";
   cur_accept:=0;
   count_transactions:=0;
   count_valid_tran:=0;
   last_pool_block:=0;
   last_pool_cl_tran:=0;
   last_pool_tran:=0;
   not_accept:=true;
   current_wallet:=-1;
   schedule FillPowers in 0;
   schedule SendTransaction in start_send;
 ende
 event FillPowers;
   i:=0;
   number:=1;
   while (i<count_p) do
    Powers[i]:=number;
    number:=number*p;
    i:=i+1;	
   endw;   
   schedule FirstBlock in 0;
   schedule FindHash in 0;
 ende
 event FindHash;
   num:=StrToCharArray(for_hash);
   hash:=0;
   i:=0;
   while((num[i] !='!') &(i<size_hash)) do
     s:=CharToStr(num[i]);	 
     hash:=hash+(StrToInt(s)*Powers[i]);
	 i:=i+1;
   endw;  
 ende
 event FirstBlock;
   prev_hash:=hash;
   block:="0";
   block:=block+" "+IntToStr(time_stamp);
   block:=block+" "+RealToStr(hash);
   block:=block+" "+"0";
   block:=block+" "+IntToStr(nonce);
   block:=block+" "+"0";
   schedule AddBlock in 0;
   schedule AddTime in 1;
 ende
 event AddBlock;
   Print "Add block";
   if (count_blocks>0) then
     ArrayBlock:=Split(block,' ');
	 i:=0;
	 while (i<count_tran_block) do
	   j:=StrToInt(ArrayBlock[i*5+8]);
	   AmountWallets[j]:=AmountWallets[j]+StrToReal(ArrayBlock[i*5+9]);
	   j:=StrToInt(ArrayBlock[i*5+7]);
	   AmountWallets[j]:=AmountWallets[j]-StrToReal(ArrayBlock[i*5+9]);
	   if (my_block) then
	     own_wallet:=own_wallet+StrToReal(ArrayBlock[i*5+10]);
	   endif;	   
	   i:=i+1;
	 endw;
	 if(my_block) then
	   own_wallet:=own_wallet+net_reward;
	 endif;  
	 prev_hash:=StrToReal(ArrayBlock[2]);
   endif;
   cur_count_tran:=0;   
   Register[count_blocks]:=block;
   count_blocks:=count_blocks+1;
   my_block:=false;
   count_res_blocks:=count_blocks;
   count_res_trans:=count_tran_block*(count_blocks-1);
 ende
 event ValidTran;   
   last_pool_cl_tran:=last_pool_cl_tran-1;
   Print "Tom wallet: "+RealToStr(AmountWallets[current_wallet]);
   ArrayMessage:=Split(pool_cl_trans[last_pool_cl_tran],' ');
   count_transactions:=count_transactions+1;
   Print "Count node trans ----- "+RealToStr(count_transactions);
   Print "Validate transaction from client";
   i:=0;
   flag:=true;
   flag2:=true;
   while ((i<count_wallets) & (flag | flag2)) do 
     if (flag & (ArrayMessage[1] = NameWallets[i]) &(i = current_wallet)) then
	    flag:=false;
	 endif;
	 if (flag2 & (ArrayMessage[2] = NameWallets[i])) then
	    flag2:=false;
		to_id:=i;
	 endif;
     i:=i+1;
   endw;
   if(!flag & !flag2) then 
    (*amount*)
    amount:=StrToReal(ArrayMessage[3]);
    reward:=StrToReal(ArrayMessage[4]);
    if( AmountWallets[current_wallet] >= (amount+reward)) then
	  count_valid_tran:=count_valid_tran+1;
      tran:=IntToStr(count_blocks)+IntToStr(RandomIn(minrand,maxrand));
	  (*Print "Send transaction #" + tran;*)
      tran:=tran+" "+IntToStr(current_wallet);
	  tran:=tran+" "+IntToStr(to_id);
	  tran:=tran+" "+ArrayMessage[3];
	  tran:=tran+" "+ArrayMessage[4];
	  Transactions[cur_count_tran]:=tran;
	  cur_count_tran:=cur_count_tran+1;
	  tran:="Tran_node"+" "+tran;
	  i:=1;	  
	  while (i<count_nodes) do
	    out tran through Con[i];
	    i:=i+1;
	  endw;
	  if cur_count_tran = count_tran_block then
	    cur_count_hashes:=0;
		fg_tree:=false;
		Print "Start mine";
	    schedule Mine in 1;
	  endif;
    endif;
   endif;
 ende
 event SendTransaction;
   if mode = 1 then     
   endif;
 ende
 event Loge;
  if last_log>0 then
   i:=0;
   Print "Log";
   while(i<last_log) do
     Print log[i];
	 i:=i+1;
   endw;
   last_log:=0;
  endif;
 ende
 event AddTime;
  if ((time_stamp % 4 = 0) & (mode =2)) then
     s:="Refresh";
	 s:=s+" "+RealToStr(AmountWallets[current_wallet]);
	 out s through Con[0];
  endif;
  time_stamp:=time_stamp+1;
  schedule AddTime in 1;
 ende
 event ValidTranNode;
   last_pool_tran:=last_pool_tran-1;
   ArrayMessage:=Split(pool_trans[last_pool_tran],' ');
   count_transactions:=count_transactions+1;
   Print "Validate transaction #"+ArrayMessage[1];
   i:=0;
   flag:=true;
   flag2:=true;
   from_id:=StrToInt(ArrayMessage[2]);
   to_id:=StrToInt(ArrayMessage[3]);
   while ((i<count_wallets) & (flag | flag2)) do 
     if (flag & (IdWallets[i]=from_id)) then
	    flag:=false;
	 endif;
	 if (flag2 & (IdWallets[i]=to_id)) then
	    flag2:=false;
	 endif;
     i:=i+1;
   endw;
   if(!flag & !flag2) then    
    amount:=StrToReal(ArrayMessage[4]);
    reward:=StrToReal(ArrayMessage[5]);
    if( AmountWallets[from_id] >= (amount+reward)) then
	  count_valid_tran:=count_valid_tran+1;
      tran:=ArrayMessage[1];
      tran:=tran+" "+ArrayMessage[2];
	  tran:=tran+" "+ArrayMessage[3];
	  tran:=tran+" "+ArrayMessage[4];
	  tran:=tran+" "+ArrayMessage[5];
	  Transactions[cur_count_tran]:=tran;
	  cur_count_tran:=cur_count_tran+1;
	  if cur_count_tran = count_tran_block then
	    cur_count_hashes:=0;
		fg_tree:=false;
		Print "Start mine";
	    schedule Mine in 1;
	  endif;
    endif; 
   endif;   
 ende
 event Mine;
   if(cur_count_hashes <count_tran_block) then    
     if (cur_count_hashes>0) then
	   MTree[cur_count_hashes-1]:=hash;
	 endif;
     ArrayTran:=Split(Transactions[cur_count_hashes],' ');
	 s:="";
	 s:=s+ArrayTran[0]+ArrayTran[1]+ArrayTran[2]+ArrayTran[3]+ArrayTran[4];
	 for_hash:=s+"!";
	 cur_count_hashes:=cur_count_hashes+1;
	 schedule Mine in 0;
     schedule FindHash in 0;
   else
    if (cur_count_hashes = count_tran_block) then
      MTree[cur_count_hashes-1]:=hash;
	  fg_tree:=true;
	  cur_leaf:=0;
	  last_leaf:=cur_count_hashes-1;
	  count_leafs:=count_tran_block;
	  for_hash:=RealToStr(MTree[cur_leaf]+MTree[cur_leaf+1])+"!";	  
	  cur_count_hashes:=cur_count_hashes+1;
	  schedule Mine in 0;
	  schedule FindHash in 0;
	else
	  if(last_leaf!=0) then    	    	
	    if cur_leaf >= last_leaf then
		  if cur_leaf = last_leaf then
		    MTree[cur_leaf]:=MTree[last_leaf];
		  endif;
		  cur_leaf:=0;
		  last_leaf:=count_leafs-1;			  
        else
		  MTree[(integer)((cur_leaf)/2)]:=hash;	
          cur_leaf:=cur_leaf+2;
          count_leafs:=count_leafs-1;	       	  
	    endif;	        	
	    for_hash:=RealToStr(MTree[cur_leaf])+RealToStr(MTree[cur_leaf+1])+"!";
		schedule Mine in 0;
	    schedule FindHash in 0;
	  else
		if(fg_tree) then
		  nonce:=RandomIn(minnonce,maxnonce);
		  count_steps:=1;
		  for_hash:=IntToStr(nonce)+RealToStr(MTree[0])+"!";	  
		  fg_tree:=false;
		  schedule Mine in 0;
		  schedule FindHash in 0;
		else
		  s:=RealToStr(hash);
		  num:=StrToCharArray(s);
		  fg_zero:=true;
		  i:=0;
		  while ((i<zero_count)&fg_zero) do
		   if(num[i] !='1') then
		     fg_zero:=false;
		   endif;
		   i:=i+1;
		  endw;
		  if(fg_zero) then
		   Print "Find nonce " + IntToStr(nonce);
		   for_hash:=RealToStr(MTree[0])+RealToStr(prev_hash)+"!";
		   schedule CreateBlock in 0;
		   schedule FindHash in 0;
		  else
		   nonce:=nonce+1;
		   count_steps:=count_steps+1;
		   for_hash:=IntToStr(nonce)+RealToStr(MTree[0])+"!";	
		   schedule Mine in 0;
		   schedule FindHash in 0;
		  endif;
		endif;  	          
	  endif;  
	endif;
   endif;
 ende
 event CreateBlock;  
   create_id_bk:=count_blocks;
   block:=IntToStr(count_blocks);
   Print "Create block #"+block;
   block:=block+" "+IntToStr(time_stamp);
   block:=block+" "+RealToStr(hash);
   block:=block+" "+RealToStr(prev_hash);
   block:=block+" "+IntToStr(nonce);
   block:=block+" "+RealToStr(MTree[0]);
   i:=0;
   while (i<count_tran_block) do
      block:=block+" "+Transactions[i];
	  i:=i+1;
   endw;  
   bk_hash:=hash;
   schedule SendBlock in 1;
 ende
 event SendBlock;
   Print "Send block";
   i:=1;
   s:="Block"+" "+IntToStr(count_steps)+" "+block;
   while (i<=count_nodes) do
      out s through Con[i];
      i:=i+1;
   endw;
   schedule SendRegister in 1;
 ende
 event CheckBlock;  
     Print "Check block"; 
     last_pool_block:=last_pool_block-1;
     ArrayBlock:=Split(pool_blocks[last_pool_block],' '); 
     for_hash:=ArrayBlock[6]+ArrayBlock[7]+"!";	 
     num:=StrToCharArray(for_hash);
     hash:=0;
     i:=0;
     while((num[i] !='!') &(i<size_hash)) do
       s:=CharToStr(num[i]);	 
       hash:=hash+(StrToInt(s)*Powers[i]);
	   i:=i+1;
     endw;      
     s:=RealToStr(hash);
     num:=StrToCharArray(s);
	 i:=0;
	 fg_zero:=true;
	 while ((i<zero_count)&fg_zero) do
	   if(num[i] !='1') then
		  fg_zero:=false;
	   endif;
	   i:=i+1;
	 endw;
	 cur_steps:=StrToInt(ArrayBlock[1]);
	 check_id_bk:=StrToInt(ArrayBlock[2]);
	 sch:="f";
	 if(fg_zero & (((check_id_bk = create_id_bk) & (cur_steps<count_steps)) | (check_id_bk>create_id_bk))) then
        sch:="t";
		(*block:=ArrayBlock[2];
		i:=3;
		while (i<=7) do
		  block:=block+" "+ArrayBlock[i];
		  i:=i+1;
		endw;
		i:=0;
		while (i<count_tran_block) do
		  block:=block+" "+ArrayBlock[i*5+8];
		  block:=block+" "+ArrayBlock[i*5+9];
		  block:=block+" "+ArrayBlock[i*5+10];
		  block:=block+" "+ArrayBlock[i*5+11];
		  block:=block+" "+ArrayBlock[i*5+12];
		  i:=i+1;
		endw;
		schedule AddBlock in 0;*)
	 endif;
	 i:=1;
	 while (i<=count_nodes) do
	     s:="Response"+" "+ArrayBlock[6]+" "+sch;
		 out s through Con[i];
	     i:=i+1;
	 endw;
 ende
 event SendRegister;
    cur_accept:=0;
	not_accept:=true;
	s:="Register"+" "+IntToStr(count_blocks);
	Print "Size "+s;
	i:=0;
	while (i<count_wallets) do
	  s:=s+" "+RealToStr(AmountWallets[i]);
	  i:=i+1;
	endw;
	i:=0;
	while (i<count_blocks) do
	  s:=s+" "+Register[i];
	  i:=i+1;
	endw;
	i:=1;
	while (i<=count_blocks) do
	  out s through Con[i];
	  i:=i+1;
	endw;
	(*
    i:=1;	
	while (i<=count_nodes)do
	  j:=0;  
	  out "Register" through Con[i];
	  while (j<count_blocks) do	     
	    out Register[j] through Con[i];
		j:=j+1;
	  endw;	  
	  i:=i+1;
	endw; *)
 ende
endrout 